<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Architecture &mdash; TbLink RPC  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interaction Protocol" href="interaction_protocol.html" />
    <link rel="prev" title="Overview" href="overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> TbLink RPC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Architecture</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#concept-model">Concept Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#environments-and-endpoints">Environments and Endpoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methods-interfaces-and-interface-types">Methods, Interfaces, and Interface Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-model">Implementation Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#user-facade">User Facade</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-implementation">Core Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#environment-integration">Environment Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automation">Automation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#use-cases-application-examples">Use-Cases / Application Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#python-driven-uvm-sequence-execution">Python-Driven UVM Sequence Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uvm-sequence-implemented-in-python">UVM Sequence Implemented in Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systemverilog-co-simulation-with-c-c-software-behavior">SystemVerilog Co-Simulation with C/C++ Software Behavior</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-driving-a-silicon-platform">Python Driving a Silicon Platform</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interaction_protocol.html">Interaction Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TbLink RPC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/architecture.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline"></a></h1>
<p>Due to the requirements for flexibility and scalability, TbLink RPC
uses a layered architecture. It’s reasonable to think of this
layered architecture as being similar to a network stack.</p>
<section id="concept-model">
<h2>Concept Model<a class="headerlink" href="#concept-model" title="Permalink to this headline"></a></h2>
<p>Let’s start with some key concepts that are used across the document.
There is implementation behind these concepts, but it’s useful to
understand their purpose at a high level before diving into the details.</p>
<img alt="_images/concept_diagram.png" src="_images/concept_diagram.png" />
<section id="environments-and-endpoints">
<h3>Environments and Endpoints<a class="headerlink" href="#environments-and-endpoints" title="Permalink to this headline"></a></h3>
<p>TbLink RPC exists to allow simulation-centric environments to
communicate. Each pair of communicating environments has a
pair of connected endpoints. An environment may communicate
with multiple other environments, but each pair of connected
environments may only be connected by a single pair of
TbLink RPC endpoints.</p>
<p>One result of TbLink RPC being simulation-centric is the
requirement to  synchronize and control time. For example, when
one environment is a simulator and the other is a testbench,
it is critical to ensure that the simulation advances only
once the testbench has responded to all pending simulation
events. If this requirement isn’t met, our ability to properly
interact with the design under test (DUT) will be impaired.</p>
<p>TbLink RPC is not a simulator co-simulation framework, with
support for synchronizing the operation of multiple simulators
each with their own notion of time. Consequently, one
environment is considered the <em>Timebase Provider</em>. The
<em>Timebase Provider</em> environment maintains the current time
for all environments, and provides support for time-based
callbacks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TbLink RPC doesn’t enforce the restriction on having only
a single Timebase Provider. This restriction is simply
a pragmatic one, given the implementation of capabilities
of most simultors today.</p>
</div>
</section>
<section id="methods-interfaces-and-interface-types">
<h3>Methods, Interfaces, and Interface Types<a class="headerlink" href="#methods-interfaces-and-interface-types" title="Permalink to this headline"></a></h3>
<img alt="_images/iftype_ifinst_mirror.png" src="_images/iftype_ifinst_mirror.png" />
<p>TbLink RPC environments communicate via method calls. Method
calls are made with respect to <em>interface instances</em>. Each
<em>interface instance</em> has an <em>interface type</em>, which captures
which methods are available.</p>
<p>An interface type specifies type and usage information about
methods. Specifically, it captures:</p>
<ul class="simple">
<li><p>The return type of the method</p></li>
<li><p>Method parameter names and types</p></li>
<li><p>Whether the method is time-consuming</p></li>
<li><p>Whether the method is an <em>export</em> or an <em>import</em>.</p></li>
</ul>
<p>This last bit – export vs import – is of critical importance.
An imported method is called by the environment, while an
exported method is implemented by the environment and called
by TbLink RPC in response to a call from the peer environment.</p>
<p>Both connected interface instances have the same interface type.
However, one is designated a <em>mirror</em> interface. A <em>mirror</em>
interface implements the “mirror” of methods, so an export
method is implemented as an import on a <em>mirror</em> interface, and
an import method is implemented as an export.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The terminology of import, export, and mirror comes from the
vocabulary of Transaction-Level Modeling and IP-XACT IP
encapsulation.</p>
</div>
<p>When defining an interface type, whether a method itself is an
import or an export is entirely irrelevant. For example, the
interface type above could have been defined with <em>Req</em> being
an import and <em>Rsp</em> being an export. The practical impact of
this decision would be that the right-hand interface instance
would need to be specified as a mirror and the left-hand
interface instance would need to be specified as a non-mirror
in order to preserve the caller/called relationship.</p>
<p>Methods may be denoted as either time-consuming or non-time-consuming.
This is a critical distinction precisely because TbLink RPC is targeted
at enabling communication with simulation environments. When
non-time-consuming methods are called, TbLink RPC understands that
time in the simulation environment must not advance. When time-consuming
methods are called, TbLink RPC understands that it may be necessary for
time in the simulation environment to advance before the method call
is complete.</p>
</section>
</section>
<section id="implementation-model">
<h2>Implementation Model<a class="headerlink" href="#implementation-model" title="Permalink to this headline"></a></h2>
<p>Implementation of TbLink RPC is split into three major components:</p>
<ul class="simple">
<li><p>User Facades</p></li>
<li><p>Core Implementation</p></li>
<li><p>Environment Integration</p></li>
</ul>
<p>As the name suggests, the user facade is the primary aspect of
interest to end users.</p>
<p>The implementation core is primarily of interest to developers
wishing to extend TbLink RPC to support another front-end
language and/or simulator integration. Core Implementation must
support all user facades and environment integrations.</p>
<p>Environment integration is responsible for handling
environment-specific details. For example, propagating events
properly in Verilog via the VPI API. Generally, environment
integration is the smallest body of code in TbLink RPC.</p>
<section id="user-facade">
<h3>User Facade<a class="headerlink" href="#user-facade" title="Permalink to this headline"></a></h3>
<p>Every language and language methodology used for functional
verification and with simulation models time and events
in some form. In standard fashion, different languages and
methodologies represent these same concepts in different ways.
For example, SystemVerilog represents time-consuming methods
as <em>tasks</em> and language constructs for modeling events, while
Python represents the same concept using <em>async</em> methods and
classes in the standard library.</p>
<p>The purpose of language- and methodology-specific facades is
to adapt TbLink RPC to the appropriate language- and
methodology-specific constructs.</p>
<p>The adaptation can go far beyond just adapting TbLink RPC to
threading and event constructs supported by the target
environment. For example, Python provides rich introspection
and annotation capabilities that enable the user to
capture meta-data for TbLink RPC directly in Python instead
of in a separate side file.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tblink_rpc</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="nd">@tblink_rpc</span><span class="o">.</span><span class="n">iftype</span><span class="p">(</span><span class="s2">&quot;rv_bfms.initiator&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">RvInitiatorBfm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@tblink_rpc</span><span class="o">.</span><span class="n">exptask</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">req</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span> <span class="p">:</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@tblink_rpc</span><span class="o">.</span><span class="n">impfunc</span>
    <span class="k">def</span> <span class="nf">rsp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>The code snippet above shows interface-type information
captured as annotations on the Python class that implements
an interface instance. Other environments may have similar
environment- or language-specific mechanisms that provide
enhanced capabilities when TbLink RPC is used with that
environment.</p>
</section>
<section id="core-implementation">
<h3>Core Implementation<a class="headerlink" href="#core-implementation" title="Permalink to this headline"></a></h3>
<p>The User Facade layer is characterized by differences. It’s goal is
to provide the best user experience possible based on the target
environment. In contrast, the Core Implementation layer is
characterized by similarity. In nearly all cases, the
Core Implementation layer for different languages and environments
have identical APIs, or very nearly identical APIs.</p>
<p>In many cases, this similarity is very important because of
cross-language reuse of the Core Implementation layer. For example,
when a SystemVerilog is connected via a socket to an executable
running as a separate process, the SystemVerilog Core Implementation
layer uses the C++ Core Implementation layer to implement
process management and socket communication.</p>
<p>With that, let’s dive into the key objects in the Core Implementation
layer.</p>
</section>
<section id="environment-integration">
<h3>Environment Integration<a class="headerlink" href="#environment-integration" title="Permalink to this headline"></a></h3>
<p>Nearly every environment requires some amount of integration
code to be able to access TbLink functionality. In many cases, this
code exists to access the C++ implementation of TbLink. In the
case of most simulation environments, some amount of code exists
to trigger events in the simulation environment. The goal is for
this environment-specific code to be as light-weight as possible.</p>
<p>Current environment integrations include:</p>
<ul class="simple">
<li><p>SystemVerilog simulation (DPI)</p></li>
<li><p>Verilog simuilation (VPI)</p></li>
<li><p>Python (Cython/C++ binding)</p></li>
<li><p>Gateware for Silicon targets (byte-oriented interface)</p></li>
</ul>
</section>
<section id="automation">
<h3>Automation<a class="headerlink" href="#automation" title="Permalink to this headline"></a></h3>
<p>A key aspect of the TbLink-RPC approach is automation to generate
boilerplate implementation code from</p>
</section>
</section>
<section id="use-cases-application-examples">
<h2>Use-Cases / Application Examples<a class="headerlink" href="#use-cases-application-examples" title="Permalink to this headline"></a></h2>
<p>Here are a few examples of TbLink RPC applications.</p>
<section id="python-driven-uvm-sequence-execution">
<h3>Python-Driven UVM Sequence Execution<a class="headerlink" href="#python-driven-uvm-sequence-execution" title="Permalink to this headline"></a></h3>
<img alt="_images/usecase_python_uvm_sequence.png" src="_images/usecase_python_uvm_sequence.png" />
<p>It is often attractive to use Python for capturing tests
because of the flexibility and familiarity of the language,
and because of access to Python libraries for algorithmic
stimulus generation. However, an existing SystemVerilog/UVM
testbench typically contains extensive infrastructure, such
as bus functional models (BFMs) and/or verification IP (VIP),
a register model, and utility sequences for performing
standard operations on the design under test.</p>
<p>Leveraging all of this existing infrastructure is highly
desirable. In order to do so, we effectively need some
Python code to run in the context of the UVM
virtual sequence running in the SystemVerilog environment.</p>
<p>The two key TbLink RPC capabilities exercised in this
application example are:</p>
<ul class="simple">
<li><p>Support for dynamically creating interface instances
and passing them between environments.</p></li>
<li><p>Making multiple blocking calls between environments.</p></li>
</ul>
<p>The key steps in this example are as follows:</p>
<ul class="simple">
<li><p>The Python environment creates a TbLink RPC
<em>interface instance</em> that corresponds to the UVM
virtual sequence.</p></li>
<li><p>The Python environment passes this <em>interface instance</em>
to a method in the SystemVerilog testbench environment,
where handles to agents and register model are populated,
and that starts the UVM sequence.</p></li>
<li><p>When the UVM testbench calls the sequence <em>body</em> task,
the body task is invoked in the Python environment.</p></li>
<li><p>The Python <em>body</em> method can now drive behavior in the
UVM testbench by calling utility methods in the virtual
sequence.</p></li>
</ul>
</section>
<section id="uvm-sequence-implemented-in-python">
<h3>UVM Sequence Implemented in Python<a class="headerlink" href="#uvm-sequence-implemented-in-python" title="Permalink to this headline"></a></h3>
<img alt="_images/usecase_sv_seq_python_impl.png" src="_images/usecase_sv_seq_python_impl.png" />
<p>This usecase is somewhat the inverse of the previous usecase.
In the previous example, the Python testbench created a sequence
and executed it in the UVM testbench. In this example, the
UVM testbench creates a sequence that is implemented in Python.</p>
<p>The key steps in this example are:
- The UVM testbench creates a SystemVerilog sequence class
that extends from a tblink-rpc implementation class
- When the sequence is run, it starts an embedded Python
interpreter and runs the specified</p>
</section>
<section id="systemverilog-co-simulation-with-c-c-software-behavior">
<h3>SystemVerilog Co-Simulation with C/C++ Software Behavior<a class="headerlink" href="#systemverilog-co-simulation-with-c-c-software-behavior" title="Permalink to this headline"></a></h3>
<img alt="_images/usecase_zephyr_integration.png" src="_images/usecase_zephyr_integration.png" />
<p>Bringing some aspects of software behavior into an IP-level
environment enables firmware to be developed during the IP
design and verification effort. One way of doing this is
to native-compile the <a class="reference external" href="https://www.zephyrproject.org">Zephyr RTOS</a>
real-time operating system and co-simulate its software
behavior with the testbench and design. The
<a class="reference external" href="https://github.com/zephyr-dv/zephyr-cosim">Zephyr-Cosim</a> project
provides integration code and uses TbLink-RPC to connect
a compiled Zephyr application to a simulation environment.</p>
</section>
<section id="python-driving-a-silicon-platform">
<h3>Python Driving a Silicon Platform<a class="headerlink" href="#python-driving-a-silicon-platform" title="Permalink to this headline"></a></h3>
<img alt="_images/usecase_silicon_platform.png" src="_images/usecase_silicon_platform.png" />
<p>Validation efforts continue past simulation onto silicon
platforms. It is highly beneficial to be able to leverage
some aspects of the pre-silicon verification environment
in the post-silicon world. A combination of TbLink-RPC,
interface code generation, and BFMs/transactors enable
a carefully-selected subset of the verification environment
to be reused from verification to validation.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="overview.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="interaction_protocol.html" class="btn btn-neutral float-right" title="Interaction Protocol" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Matthew Ballance.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>